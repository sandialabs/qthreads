<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>qt_loop_queue_create(3) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
<b>qt_loop_queue_create</b> - allocate a loop queue handle 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>#include
&lt;qthread/qloop.h&gt;</b> 
<p> <i>qqloop_handle_t</i>* <br>
<b>qt_loop_queue_create</b>( <blockquote>const qt_loop_queue_type <i>type</i>,<i></i> <br>
const size_t <i>start</i>,<i></i> <br>
const size_t <i>stop</i>,<i></i> <br>
const size_t <i>step</i>,<i></i> <br>
const qt_loop_f <i>func</i>,<i></i> <br>
void * const <i>argptr</i>);<i></i> </blockquote>

<h2><a name='sect2' href='#toc2'>Description</a></h2>
This function allocates a loop queue handle
for use with <b>qt_loop_queue_run</b>() or <b>qt_loop_queue_run_there</b>(). <p>
The <i>func</i>
argument must be a function pointer with a <b>qt_loop_f</b> prototype. Its basic
code structure is expected to look like this: <blockquote><p>
void <i>func</i> (const size_t startat,
const size_t stopat, const size_t  <i>step</i>, void * <i>arg</i>) <br>
{ <blockquote>for (unsigned int i = startat; i &lt; stopat; i += <i>step</i>) { <blockquote>/* do work */
</blockquote>
} </blockquote>
} </blockquote>
<p>
The arguments <i>startat</i> and <i>stopat</i> are determined by the library, and
tell the function what range of <i>i</i> values (iterations) it is responsible
for. <p>
The <i>type</i> argument defines which adaptive scheduling technique should
be used to schedule the processing of loop iterations. The possible values
are: 
<dl>

<dt><b>CHUNK</b> </dt>
<dd>This is the lowest-overhead method, but is the least adaptive.
A small default chunk size will be chosen by the library, and all available
worker threads will process loop iterations in groups of that size. The
chunk size can be specified with the <b>qt_loop_queue_setchunk</b>() function.
</dd>

<dt><b>GUIDED</b> </dt>
<dd>This specifies an implementation of guided self-scheduled loops,
invented by Constantine D. Polychronopoulos and David J. Kuck in 1987. Iterations
are executed in chunks that are halved in size as the loop progresses. This
is particularly efficient at slightly imbalanced loops. </dd>

<dt><b>FACTORED</b> </dt>
<dd>This specifies
an implementation of factored self-scheduled loops, invented by Susan F.
Hummel, and Edith Schonberg, and Lawrence E. Flynn in 1992. Iterations are
executed in chunks that are specified in sets. First, half of the iteration
space is handed out in equal-sized chunks to all threads, then half of the
remaining iterations are handed out in equal-sized chunks, and so forth.
This is more effective than GUIDED when loops are more imbalanced. </dd>

<dt><b>TIMED</b>
</dt>
<dd>This specifies an implementation of timed self-scheduled loops; iterations
are timed and subsequent chunks of iterations are given to worker threads
based on the length of time required by the previous iteration chunks. This
method can account for overhead better and can potentially handle wildly
imbalanced loops more efficiently than FACTORED. </dd>
</dl>

<h2><a name='sect3' href='#toc3'>Return Values</a></h2>
A pointer
to a valid qqloop_handle_t will be returned OR a NULL pointer if memory
could not be allocated. 
<h2><a name='sect4' href='#toc4'>See Also</a></h2>
<a href='qt_loop.html'><b>qt_loop</b>(3)</a>
, <a href='qt_loop_queue_run.html'><b>qt_loop_queue_run</b>(3)</a>
, <a href='qt_loopaccum_balance.html'><b>qt_loopaccum_balance</b>(3)</a>

<p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Return Values</a></li>
<li><a name='toc4' href='#sect4'>See Also</a></li>
</ul>
</body>
</html>
