<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>qthread_queue_create(3) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
<b>qthread_queue_create </b> - allocate and/or initialize a synchronization
queue 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>#include &lt;qthread.h&gt;</b> 
<p> <i>qthread_queue_t</i> <br>
<b>qthread_queue_create</b> (uint8_t <i>flags</i>,<i></i> <br>
 aligned_t <i>length</i>);<i></i> <p>
<i>int</i> <br>
<b>qthread_queue_destroy</b> (qthread_queue_t <i>q</i>);<i></i> 
<p> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
These two functions
are for allocating and deallocating qthread_queue_t objects. The <b>qthread_queue_create</b>()
function allocates and initializes a qthread_queue_t object, while the
<b>qthread_queue_destroy</b>() function deallocates one. These objects are generic
synchronization building blocks that are designed specifically for implementing
other synchronization objects. They can be used to implement mutexes, FEBs,
and even sincs, in a relatively efficient manner, given the requirement
to both initialize and destroy the associated bookkeeping structure. The
difference, for each of these, is in how the queue is used.  <p>
The creation
function takes two arguments: <i>flags</i> and <i>length</i>. The flags may be any of
the following: 
<dl>

<dt>QTHREAD_QUEUE_NO_SYNC </dt>
<dd>This specifies that the queue should
employ no synchronization; all synchronization will be done externally,
if necessary, to ensure exclusive access to both joining and releasing
the queue. The queue may have any number of entries. </dd>

<dt>QTHREAD_QUEUE_MULTI_JOIN
</dt>
<dd>This specifies that the queue should expect to have multiple concurrent,
asynchronous join operations. These join operations will be safe to execute
in parallel, but the release operation is not safe to execute in parallel
with the join operations. The queue may have any number of entries. </dd>

<dt>QTHREAD_QUEUE_MULTI_JOIN_LENGTH
</dt>
<dd>This specifies that the queue should expect to have multiple concurrent,
asynchronous join operations, and should keep track of the length of the
queue. These join operations will be safe to execute in parallel, but the
release operation is not safe to execute in parallel with the join operations.
The queue may have any number of entries. </dd>

<dt>QTHREAD_QUEUE_CAPPED </dt>
<dd>This specifies
that the queue should, like the MULTI_JOIN options, be safe to join in
parallel, but also that there is a maximum number of elements in the queue.
This allows the join operation to be faster (it need not allocate memory).
</dd>
</dl>
<p>
The <i>length</i> argument is only applicable for QTHREAD_QUEUE_CAPPED, and specifies
the fixed length of the queue. 
<p> 
<h2><a name='sect3' href='#toc3'>Return Values</a></h2>
<b>qthread_queue_create</b>() returns
an initialized qthread_queue_t object. <b>qthread_queue_destroy</b>() returns QTHREAD_SUCCESS
on success, and an error otherwise. 
<h2><a name='sect4' href='#toc4'>See Also</a></h2>
<a href='qthread_queue_destroy.html'><b>qthread_queue_destroy</b>(3)</a>
, <a href='qthread_queue_join.html'><b>qthread_queue_join</b>(3)</a>
,
<a href='qthread_queue_length.html'><b>qthread_queue_length</b>(3)</a>
, <a href='qthread_queue_release_all.html'><b>qthread_queue_release_all</b>(3)</a>
, <a href='qthread_queue_release_one.html'><b>qthread_queue_release_one</b>(3)</a>

 <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Return Values</a></li>
<li><a name='toc4' href='#sect4'>See Also</a></li>
</ul>
</body>
</html>
