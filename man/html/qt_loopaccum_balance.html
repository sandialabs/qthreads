<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>qt_loop_balance(3) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
<b>qt_loopaccum_balance</b> - a slightly intelligent implementation of a threaded
loop that returns values 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>#include &lt;qthread/qloop.h&gt;</b> 
<p> <i>void</i> <br>
<b>qt_loopaccum_balance</b> (const size_t <i>start</i>, const size_t <i>stop</i>,<i></i>  const size_t
<i>size</i>, void *<i>out</i>,<i></i>  const qt_loopr_f <i>func</i>, void *<i>argptr</i>,<i></i>  const qt_accum_f
<i>acc</i>);<i></i> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
This function provides a simple C implementation of a
threaded accumulating loop. Rather than using a pre-set number of qthreads,
however, the number of qthreads generated depends directly upon the number
of shepherds available. The idea with the accumulation is that they can
be used to collect values from multiple threads. For example, if there is
a running tally of outputs, or if the maximum return value must be retained,
this is a way to do it. <p>
These function can be thought of as akin to (but
not replicating exactly) the following code: <blockquote><p>
unsigned int i; <br>
for (i = <i>start</i>; i &lt; <i>stop</i>; i ++) { <blockquote><br>
<i>func</i> (NULL, <i>argptr</i>,<i></i> ret); <br>
<i>acc</i> (tmp, ret); </blockquote>
<br>
} </blockquote>
<p>
One qthread is spawned for each shepherd. The set of values of <i>i</i> (iterations)
is divided evenly among the shepherds, and each qthread  is assigned a
set of iterations to perform.<br>
 <p>
The <i>func</i> argument must be a function pointer with a <b>qt_loopr_f</b> prototype.
Note that this is NOT the same as <b>qt_loop_f</b> functions, as it has the extra
<i>ret</i> argument. Its basic code structure is expected to look like this: <blockquote><p>
void
<b>func</b> (const size_t startat,  const size_t stopat, void *<i>argptr</i>,<i></i> void *ret)
<br>
{ <blockquote><br>
for (unsigned int i = startat; i &lt; stopat; i++) { <blockquote><br>
/* do work */ </blockquote>
<br>
} </blockquote>
<br>
} </blockquote>
<p>
The arguments <i>startat</i> and <i>stopat</i> are determined by the library, and tell
the function what range of <i>i</i> values (iterations) it is responsible for.
<b>qt_loop_balance</b>() will not return until all of the qthreads it spawned
have exited. <p>
The <i>acc</i> argument must be a function pointer with a <b>qt_accum_f</b>
prototype. This prototype looks like this: <blockquote><p>
void <b>acc</b> (void *a, void *b);
</blockquote>
<p>
The accumulating value is stored in the memory pointed to by the <i>a</i> argument,
and a new value is passed in via the <i>b</i> argument. Keep in mind that when
there is only a single shepherd, this function is never called, as the
entire set of iterations will be given to a single instance of <i>func</i> to
perform. Because of this, and because there is no guarantee as to how the
iterations will be divided, <i>func</i> is expected to perform essentially the
same accumulation operation that <i>acc</i> does. There is also no guarantee as
to what order things will be accumulated in, so the operation needs to
be commutative if all runs of the program are expected to return the same
result. <p>
The result of the accumulations (<i>acc</i>),<i></i> if any, of the output (<i>ret</i>)<i></i>
of <i>func</i> will be stored in the memory pointed to by <i>out</i>. This memory is assumed
to be at least <i>size</i> bytes, and <i>size</i> bytes will be used for storage of all
<i>ret</i> arguments to <i>func</i> calls. 
<h2><a name='sect3' href='#toc3'>Example</a></h2>
Since this is a bit complicated a simple
example may be useful. The example is the <b>qt_double_sum</b>() function in the
library; for simplicity&rsquo;s sake, the <i>checkfeb</i> option has been removed from
this example. This function is extremely simple: <p>
double qt_double_sum (double
*array,  size_t length) <br>
{ <blockquote>double ret; <br>
<b>qt_loopaccum_balance</b> (0, length, sizeof(double),  &amp;ret, qtds_worker, array,
 qtds_acc); <br>
return ret; </blockquote>
} <p>
There are two function arguments to the <b>qt_loopaccum_balance</b>()
call, <i>qtds_worker</i> (as the <i>func</i> argument) and <i>qtds_acc</i> (as the <i>acc</i> or "accumulator"
argument). <i>qtds_acc</i> is extremely simple: <p>
static void qtds_acc (void *a,
void *b) <br>
{ <blockquote>*(double*)a += *(double*)b; </blockquote>
} <p>
The <i>qtds_worker</i> function does the real
work of adding up the numbers: <p>
static void qtds_worker (const size_t startat,
 const size_t stopat, void *array, void *ret) <br>
{ <blockquote>size_t i; <br>
double sum = (double *)array[startat]; <br>
for (i = startat + 1; i &lt; stopat; i++) { <blockquote>sum += (double *)array[i]; </blockquote>
} <br>
*(double *)ret = sum; </blockquote>
} 
<h2><a name='sect4' href='#toc4'>See Also</a></h2>
<a href='qt_loop.html'><b>qt_loop</b>(3)</a>
, <a href='qt_loop_balance.html'><b>qt_loop_balance</b>(3)</a>
 <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Example</a></li>
<li><a name='toc4' href='#sect4'>See Also</a></li>
</ul>
</body>
</html>
