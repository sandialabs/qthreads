<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>qalloc_makestatmap(3) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
<b>qalloc_makestatmap</b>, <b>qalloc_makedynmap</b>, <b>qalloc_loadmap</b> - creates or loads
a map file 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>#include &lt;qthread/qalloc.h&gt;</b> 
<p> <i>void</i> * <br>
<b>qalloc_makestatmap</b> (const off_t <i>filesize</i>, void *<i>addr</i>,<i></i>  const char *<i>filename</i>,
size_t <i>itemsize</i>,<i></i>  const size_t <i>streams</i>);<i></i> <p>
<i>void</i> * <br>
<b>qalloc_makedynmap</b> (const off_t <i>filesize</i>, void *<i>addr</i>,<i></i>  const char *<i>filename</i>,
const size_t <i>streams</i>);<i></i> <p>
<i>void</i> * <br>
<b>qalloc_loadmap</b> (const char *<i>filename</i>);<i></i> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
These functions are for
creating and/or loading memory maps. The concept is simple: create a giant
<b>mmap</b>()&rsquo;d file on disk, and allocate space out of it much like a <b>malloc</b>().
Of course, for speed and simplicity reasons, it doesn&rsquo;t work <i>exactly</i> like
a <b>malloc</b>(). <p>
The <b>qalloc_makestatmap</b>() and <b>qalloc_makedynmap</b>() functions both
will either create a file with the specified <i>filename</i>, or, if such a file
already exists, will load it. The <b>qalloc_loadmap</b>() function expects an existing
file named <i>filename</i>, will read the necessary information out of it, and
attempt to load it. <p>
The files created by <b>qalloc_makestatmap</b>() and <b>qalloc_makedynmap</b>()
will be <i>filesize</i> bytes long, prepared to serve <i>streams</i> concurrent requests,
and will be loaded at the address <i>addr</i>. <i>addr</i> may be NULL to indicate no
preference. The <b>qalloc_makestatmap</b>() function also takes an <i>itemsize</i> argument,
which specifies the size of allocations that need to be made from the file.

<h2><a name='sect3' href='#toc3'>Concept</a></h2>
There are two kinds of on-disk maps: dynamic maps and static maps.
Static maps have very lwo overhead, but have the restriction that all allocations
in them have the same size (also, they&rsquo;re slower to create, initially). Dynamic
maps allow you to decide how much memory to use for each allocation at
runtime, but have more overhead both in terms of space and time (also,
they&rsquo;re very fast to create, initially). <p>
The <b>mmap</b>()&rsquo;d files contain mutexes
to protect the allocation and deallocation operations, so the files can
actually be shared by multiple threads or multiple processes. Each thread
is mapped to a given "stream" (or set of mutexes) by its thread id, obtained
from <b>pthread_self</b>(). <p>
Because <b>mmap</b>() does not, and cannot, guarantee that
the address specified is the one that will be used, this may present a
problem. Pointers stored in this memory will be inaccurate if the file is
loaded at a different location than it was saved with. Conveniently, each
file stores the address it was first created for inside it, so that if
the <b>mmap</b>() loads the file at a different address, it is detected by the
library. The question remains, however, how to address the problem once
it has been detected. There are two ways of addressing this problem. <p>
From
the known-original location stored in the file, and the known-current location,
a "correction factor" or "offset" can be calculated. Addresses can be modified
when reading and writing from the file, such that they are made always
correct. This, however, involves a lot of overhead, particularly since the
common-case is expected to be that the file is always <b>mmap</b>()&rsquo;d into the exact
same location. <p>
The second option, which is what is currently done, is to
simply assert that the file MUST be loaded at the same location, and to
throw an error if it is not. The only reason that <b>mmap</b>() would refuse to
load the file into the specified location would be if there is some conflict
and something else is already occupying that memory. This is considered
to be the programmer&rsquo;s responsibility to ensure that this does not happen.
Additionally, if the system can use a 64-bit address space, there should
be more than sufficient space in that address space to find a location
that never conflicts. 
<h2><a name='sect4' href='#toc4'>See Also</a></h2>
<a href='qalloc_checkpoint.html'><b>qalloc_checkpoint</b>(3)</a>
, <a href='qalloc_cleanup.html'><b>qalloc_cleanup</b>(3)</a>
, <a href='qalloc_free.html'><b>qalloc_free</b>(3)</a>
,
<a href='qalloc_malloc.html'><b>qalloc_malloc</b>(3)</a>
  <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Concept</a></li>
<li><a name='toc4' href='#sect4'>See Also</a></li>
</ul>
</body>
</html>
